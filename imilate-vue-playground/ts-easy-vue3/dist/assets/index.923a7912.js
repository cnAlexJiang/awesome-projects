var p = Object.defineProperty; var h = (e, t, n) => t in e ? p(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var f = (e, t, n) => (h(e, typeof t != "symbol" ? t + "" : t, n), n); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const o of document.querySelectorAll('link[rel="modulepreload"]')) s(o); new MutationObserver(o => { for (const r of o) if (r.type === "childList") for (const c of r.addedNodes) c.tagName === "LINK" && c.rel === "modulepreload" && s(c) }).observe(document, { childList: !0, subtree: !0 }); function n(o) { const r = {}; return o.integrity && (r.integrity = o.integrity), o.referrerpolicy && (r.referrerPolicy = o.referrerpolicy), o.crossorigin === "use-credentials" ? r.credentials = "include" : o.crossorigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r } function s(o) { if (o.ep) return; o.ep = !0; const r = n(o); fetch(o.href, r) } })(); function m(e, t) { if (!!e._el) if (e.tag !== t.tag) e._el.replaceWith(document.createElement(t.tag)); else { t._el = e._el; const { props: n } = t.data || {}, { props: s } = e.data || {}, o = e._el; n && s && Object.keys(n).forEach(r => { const c = n[r], l = s[r]; c !== l && o.setAttribute(r, c) }), s && Object.keys(s).forEach(r => { n[r] || o.removeAttribute(r) }) } } function d(e, t) { const { tag: n, data: s = {}, children: o } = e, { props: r, on: c } = s || {}, l = e._el = document.createElement(n); if ((r || Array.isArray(r)) && r.forEach(i => { l.setAttribute(i, r[i]) }), c && typeof c == "object" && Object.keys(c).forEach(i => { l.addEventListener(i, c[i]) }), typeof o == "string") { const i = document.createTextNode(o); l.append(i) } Array.isArray(o) && o.forEach(i => { d(i, l) }), t.append(l) } let u; class g { constructor(t) { f(this, "effects"); f(this, "_value"); this.effects = [], this._value = t } get value() { return this.depend(), this._value } set value(t) { this._value = t, this.notify() } depend() { u && this.effects.push(u) } notify() { this.effects.forEach(t => { t() }) } } const v = e => new g(e); function y(e) { u = e, e(), u = null } function E(e) { return { mount(t) { if (!t) { console.warn("error with no root"); return } let n = !1; const s = e.setup(); let o; y(() => { if (n) { console.log("should diff"); const r = e.render(s); m(o, r), o = r } else { n = !0; const r = e.render(s); o = r, d(r, t) } }) } } } function a(e, t, n) { return { tag: e, data: t, children: n } } const b = { setup() { return { counter: v(0) } }, render(e) { return console.log("render", e), a("div", null, [a("div", null, String(e.counter.value)), a("button", { on: { click: () => { console.log("click"), e.counter.value = e.counter.value + 1 } } }, "add")]) } }; E(b).mount(document.querySelector("#app"));
